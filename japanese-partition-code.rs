/// スライスセグメント `arr[low..=high]` を、3点中央値ピボット選択を用いた
/// Hoare（ホアー）パーティショニング方式で分割します。
///
/// インデックス `p` を返し、要素 `arr[low..=p]` はピボット以下、
/// 要素 `arr[p+1..=high]` はピボット以上となります。
/// 注意: ピボット要素自体は必ずしもインデックス `p` に配置されるとは限りません。
///
/// # 引数
///
/// * `arr`: パーティショニングされる可変スライス。
/// * `low`: セグメントの開始インデックス。
/// * `high`: セグメントの終了インデックス。
///
/// # 戻り値
///
/// パーティショニングインデックス `p`。
fn partition_hoare<T: Ord + Debug>(arr: &mut [T], low: usize, high: usize) -> usize {
    // --- 3点中央値ピボット選択 ---
    // 中央のインデックスを計算。(low + high) / 2 と比較してオーバーフローを避けます。
    let mid = low + (high - low) / 2;

    // low, mid, high要素を順序付けして中央値を見つけます。
    // 中央値の要素を `low` インデックスに配置し、ピボットとして使用します。
    // これにより、ソート済み/逆ソート済みの配列に対する最悪時間計算量O(n^2)を回避できます。
    if arr[mid] < arr[low] {
        arr.swap(mid, low);
    }
    if arr[high] < arr[low] {
        arr.swap(high, low);
    }
    // これでarr[low] <= arr[high]となります。arr[mid]がその間にあることを確認する必要があります。
    if arr[high] < arr[mid] {
        arr.swap(high, mid);
        // このスワップ後、元の順序が例えばhigh < low < midだった場合、
        // arr[mid]が再びarr[low]より小さくなる可能性があります。
        // 再確認して、arr[low]が3つの中で最小であることを確認します。
        if arr[mid] < arr[low] {
            arr.swap(mid, low);
        }
    }
    // これでarr[low] <= arr[mid] <= arr[high]となります。中央値はarr[mid]です。
    // 中央値(arr[mid])をピボット位置(arr[low])にスワップして
    // 以下に実装するHoareのパーティショニング方式に使用します。
    arr.swap(low, mid);
    // ピボット値は現在 `arr[low]` です

    // --- Hoareパーティショニング ---
    // `low`の要素をピボット値として使用します。
    // `i`をlowの直前から、`j`をhighの直後から始めます。
    // do-whileスタイルのループ（または同等のRustのloop + break）を使用するためです。
    // 代替として、i = low, j = highから始めてピボット値を直接使うこともできます。
    // 一般的なアプローチを使用しましょう：ピボットはarr[low]の値、
    // iはlow + 1から走査、jはhighから走査します。

    let pivot_value = &arr[low]; // Tがコピー不可の場合にクローンを避けるために参照を使用します。
                                // 注意: この参照はarr[low]がスワップされると無効になります。
                                // Hoareの方式ではピボットの交換を最後まで避けますが、
                                // 値の比較を慎重に扱う方が安全です。
                                // より単純なアプローチとして、TがCloneならクローンを使う、
                                // またはインデックスで慎重に作業することも考えられます。直接比較にこだわりましょう。

    // 走査用のポインタを初期化します。
    let mut i = low; // 左からのポインタ（ピボットが交換された場合はピボットの直後から）
    let mut j = high + 1; // 右からのポインタ

    loop {
        // ピボット以上の要素が見つかるまで `i` を右に移動します。
        // 最初にarr[low]にあるピボット値に基づいて、厳密な「より小さい」比較を使用します。
        loop {
            i += 1;
            if i > high || arr[i] >= arr[low] { // 元々arr[low]にある*値*と比較
                break;
            }
        }

        // ピボット以下の要素が見つかるまで `j` を左に移動します。
        // 最初にarr[low]にあるピボット値に基づいて、厳密な「より大きい」比較を使用します。
        loop {
            j -= 1;
            // j > lowのチェックはピボットインデックス自体を超えることを防ぎます
            if j == low || arr[j] <= arr[low] { // 元々arr[low]にある*値*と比較
                break;
            }
        }

        // ポインタが交差または一致した場合、パーティショニングは完了です。
        if i >= j {
            break;
        }

        // `i` と `j` の要素が間違った側にあるため、交換します。
        arr.swap(i, j);
    }

    // ループはi >= jのときに終了します。`j`が最終的なパーティションインデックスです。
    // 元のピボット要素（`low`にある）と`j`にある要素を交換します。
    // これによりピボット値がほぼソートされた位置に配置されます。
    arr.swap(low, j);

    // パーティションインデックス `j` を返します。
    // 要素arr[low..=j]はピボット以下、要素arr[j+1..=high]はピボット以上です。
    j
}
